读写方法

目标：了解哈希表和B+树具体的原理；知道什么情况下使用什么索引；什么索引适合什么查询



 - 哈希表

   - 哈希函数

     - 描述信息

       - 理想状态：① 高性能；② 唯一

       - 原理：针对给出的数据x进行哈希函数的计算，从而给出了一个定长且唯一的y。那么就可以根据y来建立索引

       - 特性：只能做精确的匹配查找，不能做模糊匹配查找

   - 哈希碰撞

     - 当在一个集合X — Y 之间存在n个数据，n趋向于正无穷，那么在这n之中就可能存在两个数据经过哈希计算得到的哈希值是相同的

     - 原因：因为哈希值唯一只是在理论中的，是人们的理想状态，到生产实践中很难落实。

     - 解决方法：在哈希后得到的数据节点上加上链表并存入其中，当需要查找时可以根据各种方法来找出对应的数据。

     - 遍历时间：O(n），链表是顺序访问

   - 常见的哈希函数

     - CRC - 64：一般情况下最常用，用于网络数据包错误检测

     - MurmurHash

     - Google CityHash

     - Facebook XXHash

     - Google FarmHash

   - 哈希Schema：本质上是找不到完美的哈希函数的补救措施

     - 哈希分类

       - 静态哈希

         - 开放寻址法：性能上碾压一切。当哈希函数计算出的插入位置不可用时，按某种规律探测其他可用位置的方法

         - 拉链法：每个哈希桶下都有一个链表

         - 多重哈希法：正如其名，用多个不同的哈希函数嵌套计算

       - 动态哈希
         - 多哈希表：当进行哈希计算后发现有相同的哈希值，那可以将得到的哈希值再进行一次哈希计算，直到哈希值不重复为止。质量不够数量来凑

 - B+树

   - 特性：支持范围查找和模糊匹配

   - 通常节点有两个指针指向相邻的兄弟节点

   - 叶子节点只能存数据

   - B+树根据层数估算存储的数据量：（（Page大小 - 元数据大小）/ 元组大小 ）^   层数

     - Page大小：4k ~ 16k
     - 元组大小：数据库中存的行就是元组，其大小根据行数来算

     - B+树通常为三层

   - 定义的顺序会影响到查找方式与速度，有些时候放在前面就能加快查找

   - Sorted Key Map 是一种微优化

     - 将每个元组的前一个字符提取出来使用数组保存，这样查询对比时，如果第一个字符就不相等，那么可以直接跳过

- 聚簇索引：即主键
  - 如果没有主键，mysql会自动定义

- 优化：使B+树变得更快
  - 前缀压缩：就是将多个key中具有相同的前缀压缩掉（即忽略）
  - 后缀截断：当特定的节点能够判断不同的key时，可以将后面的去掉
  - 批量插入：将整个表删除，创建一个新的表并将数据导入，这样就可以建立个很完美的索引
  - 指针混用：不用了解

- Trie树：个人理解是将整个字符串拆解为一个个的字符，如hello与heat，分为h.e.l.l.o和h.e.a.t，在找到第三个字符就可以区分是hello还是heat



- 算子执行

  - 算子：由多个可执行算法组合而成

  - 排序和聚合

    - 归并排序
      - 通过map分离数据集为一个个小的数据集运算处理，处理完后再所有小的数据集reduce合并为一个数据集

    - 快速排序

  - 进程模型

    - 每一个进程负责一个worker
      - 使用共享内存实现缓存池共享
      - 一个线程崩溃了不会影响另一个worker，因为崩溃是隔离的
    - 每一个线程负责一个worker

  - 进程池/线程池

    - 工作窃取机制：能够充分利用工作线程的计算能力



- 查询计划
  - 基于条件搜索
  - 基于成本搜索
    - 基于成本模型：通过旧数据进行统计得到的模型
    - 如有基本成本模型可以再执行计划前知道查询计划的成本
    - 没有成本模型也可以同时执行多个计划，然后返回最快的查询计划返回的结果。如MongoDB
  - 架构
    - 客户端 --> SQL重写器 --> SQL解析器 --> 绑定器 --> Tree重写器 --> 优化器 --> 执行器



- 并发控制

  主要分为数据库的并发和业务上的并发

  - 数据库并发

    - ACID
      - A ：原子性
      - C ：一致性
      -  I ：隔离性
      - D ：持久性
    - CAP 定理
    
  - BASE理论：BA 指的是基本业务可用，支持分区失败。S 表示柔性状态，也就是允许短时间内不同步，E 表示最终一致性，数据最终是一致的。原子性A 和持久性D 必须从根本上保障，为了可用性、性能和服务降级的需要，只有降低一致性C和隔离性I的要求。
  
    - 基本业务可用：A 区内的业务可用，但A到B的业务就不可用了，只在自己的区内可用
    - 支持分区失败：允许A、B之间的业务失败
    - 最终一致性等于没有一致性
  
    - 不符合 ACID 的系统通常以BASE冠名。BASE 唯一可以做的事情就是不承认 ACID，此外没有任何保证。
    - 一般用在不及时的消息、文本、网盘。
    
  - CAP理论
  
    - C：一致性
    - A：可用性
    - P：分区容错性
    - zk 实现了cp原则、etcd 实现了ap原则
    
  - 事务
  
    - 事务是由一组操作构成的可靠的独立的工作单元，具有原子性、一致性、隔离性和持久性。它不是天然存在的，目的是简化编程模型。
    
    - 两个机器处理事情，要么一起完成，要么一起失败
  
    - 事务的实现方式
    
      - 重做日志 - 保证原子性
        - 将事务执行过程中的变更操作的信息保存到日志中去
        - Redo
          - 具有内存缓冲区
        - Undo
          - 实现事务回滚
        - MySQL、rabbitMQ 都存在状态
      - 影子分页 - 保证原子性
        - 创建两个页，如果成功就将原来的覆盖掉；因为使用影子分页会产生新的页，因此会产生数据碎片
      
    - k8s - pod：设计之初是为了包装进程，进程包装了权限相关的
    
      - 实现方式
    
        - sidecar
          - 有一个主要业务，其他业务是用来辅助主要业务的
        - flat
          - 两个以上的业务进程
      
    - 一致性
    
      - 数据库系统的一致性与分布式系统的一致性
    
        - 数据库的一致性在于ACID的一致性，也就是关乎操作的一致性，分布式系统的一致性更加注重数据的一致性
    
        - 数据库的一致性核心在于约束，约束是由数据库的使用者告诉数据库系统的
    
          - 约束：逻辑外键、物理外键
    
            - 逻辑外键
              - 允许短暂的时间内数据不一致，但最后会一致
              - 用在淘宝上
    
            - 物理外键
              - 将一致性事务实现，全部交给了数据库完成
              - 性能不高
              - 用在转账业务上
    
        - 外部一致性的核心是并发控制，实现外部一致性的核心是可串行化和可线性化。
    
        - 数据库系统存在事务的并发控制问题，并且ACID的隔离性受到并发控制的影响。
      
    - 隔离性
    
      - 即有两个以上业务在对数据进行操作时相互分离开，在事务提交前不允许其他人操作
    
      - 又叫并发控制，本质假装没有发生
    
      - SQL四种隔离级别
    
        - 读未提交
    
          - 可以读取其他修改但未提交的数据，会形成脏读、幻读和不可重复读
    
          - 脏读
            - 在 A 执行中修改了数据 x 并未提交，这时 B 读取了数据x，而 A 回滚了，数据x变更为修改前的数据x,而 B 读的是修改后的数据x，这就形成脏读
            - 可以使用锁，但不能使用读锁。因为不清楚写事务什么时候能结束，而且不止一个事务读数据
          - 幻读
            - 事务 A 在按照条件读取数据时，B 插入了一条数据，之后 A 按照之前的条件再次读取数据，发现多了一条数据
            - 坏处：事务A 读取的不是新数据，不精确
          - 不可重复读
            - 和幻读相反，在读数据时删除一条数据，再次读取时发现数据少一条
    
        - 读已提交
    
          - 只能读已经提交的数据，避免脏读；不能避免“幻读”与“不可重复读”
    
        - 可重复读
    
          - 锁定已经读取的数据，在当前事务提交前不准修改；不能避免“幻读”
    
        - 可串行化
    
          - 在读取前就锁定所以要读的数据，在事务提交前不允许其他事务修改
          - 最严厉的级别
          - 事务串行执行，资源消耗量大
          - 该级别直接避免了并发，也就没有了并发的问题
            - OLTP是只更新某几个行；以读为主是因为操作数据先要将行读出来
    
      - 快照隔离级别
    
        - 通常采用写锁方式避免脏写的出现
        - 实现快照隔离级别的技术叫做 MVCC
        - 实现过程中需要事务ID，事务ID 通常为32位整数，大约在40亿次后会溢出
      
    - 事务的分类
    
      - 扁平事务
        - 带保存点的扁平事务
      - 链事务
      - 嵌套事务
        - 是一颗树
      - 分布式事务（DTX）
        - 在同一层次，不同的系统中的事务
      
    - 多版本并发控制（MVCC）
    
      - 需要通过事务ID决定哪些对象可见，因此实现MVCC的过程中需要精心定义规则。
      
    - 本地事务
    
      - 资源管理器：本地的数据库
      - 支持严格的ACID特性
      
    - 全局事务
    
      - 全局事务管理器：可以是由自己开发的管理器
      
    - TX协议
    
      - 应用服务器与事务管理器的接口
      
    - XA协议
    
      - 全局事务管理器与资源管理器的接口
      
    - AP
    
      - 应用程序。可以理解为使用DTP（Data Tools Platform）的程序
      
    - RM
    
      - 资源管理器，可以是一个DBMS或者消息服务器管理系统
      
    - TM
    
      - 事务管理器，负责协调和管理事务
      
    - 2PC（两阶段提交协议）
      
      - 强一致性
      
      - XA是协议，也是用于全局事务中协调多个资源的机制，因为需要遵循协议也可以当成一种机制
      
      - TM 和 RM
        - 多个 RM 将请求发给 TM ，TM 来判断并返回请求给 RM ，因为 TM 是单点，因此 TM 发生故障，RM 就无法使用
      
    - 3PC （三阶段提交协议）
      
      - 强一致性
      
      - 事务提交过程分为 canCommit 、 preCommit 和 doCommit
      - canCommit ---> preCommit ---> doCommit
      - 在预提交 preC下 已经是落盘的状态了，只是标记还是preC，需要询问系统是否能修改状态为 doC，如果允许这时才是真正的落盘
      
    - 业务系统中柔性事务的服务模式
    
      - 可查询操作
      
      - 幂等操作
        - http中get是幂等操作，post是创建，不是幂等操作、
        - 在请求中携带id，进来要查询是什么状态，执行中返回请等待，执行成功返回执行成功，执行失败返回再次执行
        
      - TCC 操作
        
        - 最终一致性
        
        - Try 阶段：尝试执行业务，成功则加锁预留资源
        - Confirm 阶段：真正的执行，需要满足幂等性
        - Cancel 阶段：取消执行，需要满足幂等性
        - TCC 与 2PC（两阶段提交）协议的区别
          - TCC 位于服务层而不是资源层，server 连接 数据库 ，因此server实现了TCC；TCC 没有单独准备阶段；Try操作兼备资源操作和准备能力
          - Try操作可以灵活选择业务资源
          - TCC 开发成本高于 2PC ，因为需要提供框架
        
      - 可补偿操作
      
      - Saga操作
        - 事件模式
          - 个人理解是事务在执行过程中大家可以随意挂在事件，而事件与事件之间也能挂载，这样就形成了一个回环。相互挂载的事件之间相互补偿，回滚的时候就会产生bug
        - 命令模式
          - 定义一个协调者来协调操作





































