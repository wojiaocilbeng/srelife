数据库出现的主要目标就是存入数据，并且通过方法取出



###### 数据库系统的构建可以分为五层：



1、查询计划：查询数据按照步骤进行；将sql语句进行语义的差分，解释器；逻辑计划，性能低，逻辑计划 > 物理计划 ，在到存储管理



2、算子执行：就是算法的集合



3、访问方法：访问数据时需要一堆访问方法，例如读、写



4、缓冲池管理：因为存入磁盘速度很慢，需要在内存中构建缓冲池



5、存储管理：因为数据库就是用来存数据的；数据存入磁盘中；存储引擎；mongodb-WiredTiger、mysql-innodb



###### 在存储管理中使用的存储器排序（按照访问速度）



1、CPU寄存器



2、CPU缓存



3、动态内存



4、固态硬盘



5、机械磁盘



6、网络存储



innodb的定义和表的存储是分开的吗？

是分开的 



内存通常用段来表示数据块，段的下面是页，每个页都有一个全局pageID



###### 每个块大小是固定的，一般是1/2KB~4KB之间，块尺寸太大或太小都不好

因为

（1）HDFS的块设置太小，会增加寻址时间，程序一直在找块的开始位置；

（2）如果块设置的太大，从磁盘传输数据的时间会明显大于定位这个块开始位置所需的时间。导致程序在处理这块数据时，会非常慢。

总结：HDFS块的大小设置主要取决于磁盘传输速率。



数据库通常用页来表示数据块



###### 数据库的元数据存储方式：

①有的数据库将元数据与数据分开放在不同的页，例如页2中存有数据A ，页1存有数据A的元数据



②有的数据库会将元数据和数据存放在一起，在页中开辟一个空间存放元数据，又称为独立的页，

​	这样有利于灾备，例如Oracle。因为在备份数据的过程中，拷贝是按照页拷贝的

​	

###### 操作系统的mmap

简单来说就是懒加载，即用一点才加载一点数据到内存中，这对数据库是不行的，因为数据库希望自己想要的数据都在内存中



###### Indirection层：

简单来说就是一张逻辑表格，用于当磁盘移动之后，能够让上游操作通过Indreection来寻找到磁盘的相应位置，这样就不要改变pageID



###### 页的三种概念:

硬件的页︰硬件存储暴露的组织数据存储的概念，并且是原子读写的数据块大小，通常是**4KB**；在磁盘中

例如16KB，可能前8KB数据写入了，由于异常，剩余的8KB也写入了，但是不连续，导致是损坏的数据。

操作系统的页:从存储设备上取出数据放到内存中的表示，通常是**4KB**；在内存中，页里面有各种段

数据库系统的页:通常是**512B- 16KB**。



在存储引擎中，不关心页中有什么，用户才关心

页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率

分页仅仅是由于系统管理的需要，而不是用户的需要

页的大小固定且由系统确定，把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而一个系统只能有一种大小的页面

###### 段

段是信息的逻辑单位，它含有一组其意义相对完整的信息

分段的目的是为了能更好的满足用户的需要

段的长度却不固定，决定于用户所编写的程序，通常由编辑程序在对源程序进行编辑时，根据信息的性质来划分





###### **RDB 与 AOF**

###### RDB机制



RDB其实就是把数据以快照的形式保存在磁盘上。什么是快照呢，你可以理解成把当前时刻的数据拍成一张照片保存下来。



RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb；没有顺序







###### AOF机制



全量备份总是耗时的，有时候我们提供一种更加高效的方式AOF，工作机制很简单，redis会将每一个收到的写命令都通过write函数追加到文件中。通俗的理解就是日志记录。



删除元组会产生存储空洞，因此不会释放空间，除非将整个表干掉

存储空洞：即删除的数据的位置不会让其他数据移动上来，因为这样可能会移动很多的数据，造成性能降低



###### **slotted pages**



在数据页头的区域设置一个slot array，来记录元组的偏移量；例如数据b删除了，那么就在slot array中将数据b命名为0，其他存在的数据命名为1，系统每隔16kb扫描一次



缺点：

​	Slotted Pages方案无法解决变长元组带来的空间损失，因为Slotted Pages只是记录了数组的初始和结束的位置，当数组边长是就会存不开

​	

OLTP 通常是行存储



WAL预写入机制就是结构化日志，aof也是

优点是容易回滚



缺点：不利于读数据，因为当读取某样数据时要从头开始

###### 元组

布局分为数据区和元数据区



###### **面向行(事务型) 数据库**

该类数据库是根据记录(record)组织数据的，将所有与记录相关联的数据保存在内存中。面向行的数据库是组织数据的传统方式，并且为快速存储数据提供了一些关键优势。它们经过优化，可以高效地读取和写入行。

常见的面向行的数据库:

PostgreSQL

MySQL

**优点**

行存储的写入是一次性完成，消耗的时间比列存储少，并且能够保证数据的完整性;

insert/update更容易

**缺点**

没有索引的查询会产生大量的I/O

建立索引需要花费大量时间和资源

面对查询的需求，数据库必须被大量膨胀才能满足性能的需求



###### **面向列(分析型) 数据库:**

该类数据库是按字段组织数据的，在内存中将所有与字段相关联的数据保存在一起。该类数据库在读取和计算列有明显的优势。

常用的面向列的数据库

AWS RedShift

Google BigQuery

HBase

**优点**

只查询涉及的列，会大量降低系统I/O,适合并发查询

数据类型一致，数据特征相似，能对数据进行高效压缩

非常适合做聚合操作

**缺点**

缺乏数据完整性保证，写入效率低

不适合频繁delete/update操作