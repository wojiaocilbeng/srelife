缓冲池为数据库页提供工作内存和高速缓存。



​	缓冲池通过允许从内存（而不是磁盘）中访问数据来提高数据库系统的性能。由于大多数页数据处理发生在缓冲池内，因此配置缓冲池是唯一的最为重要的调整环节。



##### **page table 和 page directory 的区别**



Page Table是内存中的结构，维护缓冲池与Page lD的映射关系﹔需要确保是线程安全的，即多个线程去修改a不会出现并发问题；一对一



Page Directory是数据库文件的存储结构；存储引擎上的结构



mysql中有两个专门存储元数据的数据库：**informance_schema**；都不在磁盘上，是虚拟的数据库





##### **Lock和Latch的区别:**



​	Lock是数据库系统的逻辑原语，用于保护数据库的逻辑内容；逻辑内容：数据库保存的数据



​	Latch是一种底层保护原语，用于保护数据库系统物理结构的关键部分（数据结构或者内存中的数据)，Latch一般会使用自旋锁。oLock的对象是事务，Latch的对象是线程。所以Lock保护的对象是数据库数据，而Latch是保护内存中的数据结构。



​	Lock发生在整个事务过程中，而Latch是产生临界资源的时候。



​	Lock主要的实现是行锁，表锁，意向锁;Latch的主要实现是操作系统级别的读写锁和互斥量。



​	Lock的死锁检测手段一般是等待图，依赖图或者超时机制，Latch一般不存在死锁检测和处理机制，只是通过应用程序加锁顺序保证没有死锁的情况发生。。因此Lock被锁管理器（可以实现为一个进程，从事务接收消息并反馈)的哈希表所容纳，Latch则在数据库系统实现的代码中。





数据库发生死锁，发生的是latch锁；应用发生死锁导致数据库死锁了的，发生的是lock锁



lock是**数据库提供的锁**的概念；latch是数据库系统实现数据库系统中代码里面加的**操作系统提供的锁**



lock是事务级别的；专门锁数据的



##### **如何为缓冲池分配足够的内存空间?**

全局策略:针对整个系统来考虑，所做出的的解决会使得整个系统受益



局部策略∶针对每个查询或者事务来考虑，但是对于整个系统可能是糟糕的；因为考虑的问题不全面





##### **多缓存池**



​	数据库可以存在多个缓冲池，每个缓冲池都有自己的Page Table维护一套Page lD到Frame的映射。这样做是为了可以在每个缓冲池上使用局部策略并且减少Latch争用的出现。



因为当只有一个缓冲池，当有多个线程去访问同一个表，那么竞争量就高了



##### **预读取**



主要原理是在开机加载操作系统的时候读取常用程序的主要内容以备该程序启动时耗费大量时间来读取本身的数据，从而建设查询线程的停顿等待



##### **扫描共享**



是将一份数据尽可能多的用于多个查询线程；不等同于结果缓存，结果缓存是sql语句产生的结果；缓存执行前的数据



##### **缓冲池旁路**



因为对缓冲池的读写会污染缓冲池，读完后会删除数据。因此当不需要非常频繁的查询缓冲池时，可以开辟另一个临时的内存，用完直接删除



##### 缓冲池替换策略



LRU：

当访问数据时，内存就会从磁盘中将数据提取到缓冲池中，每个数据都会附上时间戳，当超过设置的时间戳是就会删除缓冲池中的数据

LRU-K：

只有被访问多次的数据才会存入缓冲池中



LRU 的缺点

​	虽然LRU对突发性的稀疏流量（sparse bursts）表现很好，但同时也会产生缓存污染，举例来说，如果偶然性的要对全量数据进行遍历，那么“历史访问记录”就会被刷走，造成污染；简单来说就是当遍历的数据过多时，会将原本需要的老数据刷新掉

​	

Clock

​	是最近未使用的算法，即将最近没有使用的数据删除；

​	需要设置一个环形缓冲池，还要有一个旋转的指针来检查哪些page需要移除